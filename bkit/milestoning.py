"""Tools for estimation and analysis of Markovian milestoning models."""

import collections
import msmtools.estimation as estimation
import msmtools.util.types
import numpy as np
import scipy.spatial
import bkit.ctmc as ctmc


class MarkovianMilestoningModel(ctmc.ContinuousTimeMarkovChain):
    """A milestoning process governed by a continuous-time Markov chain.

    Parameters
    ----------
    transition_kernel : (M, M) array_like
        Matrix of milestone-to-milestone transition probabilities. Must 
        be a row stochastic matrix (each row sums to 1) with all zeros on
        the diagonal. 
    mean_lifetimes : (M,) array_like
        Vector of average milestone lifetimes.
    milestones : sequence
        List of milestone labels. Values must be unique and hashable.
           
    """

    def __init__(self, transition_kernel, mean_lifetimes, milestones):
        Q = ctmc.rate_matrix(transition_kernel, 1/np.asarray(mean_lifetimes))
        super().__init__(Q, states=milestones)

    @property
    def milestones(self):
        """list: Alias self.states."""
        return self.states

    @property
    def transition_kernel(self):
        """(M, M) ndarray: Alias self.jump_matrix."""
        return self.jump_matrix

    @property
    def mean_lifetimes(self):
        """(M,) ndarray: Reciprocal of self.jump_rates."""
        return 1 / self.jump_rates

    @property
    def stationary_flux(self):
        """(M,) ndarray: Stationary flux vector."""
        return self.stationary_probability * self.jump_rates

    @property
    def stationary_probability(self):
        """(M,) ndarray: Alias self.stationary_distribution."""
        return self.stationary_distribution


class MarkovianMilestoningEstimator:
    """Maximum likelihood and Bayesian estimation of Markovian 
    milestoning models.
        
    Parameters
    ----------
    reversible : bool, default True
        If True, enforce detailed balance.

    See Also
    --------
    MarkovianMilestoningModel
        Class of models generated by this estimator.

    Notes
    -----
    Detailed balance means that the transition kernel :math:`K` of the
    milestoning model satisfies the condition 
    :math:`q_a K_{ab} = q_b K_{ba}`, where :math:`q` is the stationary
    flux vector.

    Estimation of the transition kernel (which is the transition matrix 
    of an embedded discrete-time Markov chain) is performed using the 
    methods discussed by Trendelkamp-Schroer et al. [1]_ and implemented 
    in the :mod:`msmtools.estimation` module.

    References
    ----------
    .. [1] B. Trendelkamp-Schroer, H. Wu, F. Paul, and F. Noe. Estimation
        and uncertainty of reversible Markov models. J. Chem. Phys. 
        143, 174101 (2015).
    
    """

    def __init__(self, reversible=True):
        self.reversible = bool(reversible)
        self._model = None

    @property
    def reversible(self):
        """bool: Whether to perform reversible estimation."""
        return self._reversible

    @reversible.setter
    def reversible(self, value):
        self._reversible = bool(value)
 
    @property
    def count_matrix(self):
        ...

    @property
    def total_times(self):
        ...

    @property
    def milestones(self):
        ...        

    def fit(self, schedules):
        """Fit the estimator to milestone schedule data.

        Parameters
        ----------
        schedules : iterable of Sequence[tuple[frozenset, float]]
            Sequences of (milestone index, lifetime) pairs. Transitions 
            to or from milestones bordering unassigned cells (index -1) 
            are ignored.

        Returns
        -------
        self : MarkovianMilestoningEstimator
            Reference to self.

        Notes
        -----
        For users with data in the form of individual 
        milestone-to-milestone first-passage times, a first-passage event 
        from milestone ``a`` to milestone ``b`` after a time ``t`` can be 
        represented by a schedule ``[(a, t), (b, 0)]``.

        """
        first_passage_times = collections.defaultdict(list)
        for schedule in schedules:
            a, t = schedule[0]
            for b, s in schedule[1:]:
                if type(a) != frozenset or type(b) != frozenset:
                    raise TypeError('milestone indices must be frozensets')
                if t <= 0:
                    msg = 'nonterminal milestone lifetimes must be positive'
                    raise ValueError(msg)
                if t < 0:
                    msg = 'terminal milestone lifetime must be nonnegative'
                    raise ValueError(msg)

                if -1 not in a and -1 not in b:
                    first_passage_times[a, b].append(t)
                a, t = b, s
        
        milestones = ({a for a, _ in first_passage_times}
                      | {b for _, b in first_passage_times})
        milestones = sorted(milestones, key=lambda a: sorted(a))
        ix = {a: i for i, a in enumerate(milestones)}
        m = len(milestones)

        count_matrix = np.zeros((m, m), dtype=int)
        total_times = np.zeros(m)
        for (a, b), times in first_passage_times.items():
            count_matrix[ix[a], ix[b]] = len(times)
            total_times[ix[a]] += sum(times)
        
        connected = estimation.largest_connected_set(count_matrix,
            directed=(True if self.reversible else False))
        milestones = [milestones[i] for i in connected]
        count_matrix = count_matrix[connected, :][:, connected]
        total_counts = count_matrix.sum(axis=1)
        total_times = total_times[connected]

        K = estimation.transition_matrix(
            count_matrix, reversible=self.reversible)
        np.fill_diagonal(K, 0)
        t = total_times / total_counts
        self._model = MarkovianMilestoningModel(K, t, milestones)

        self._first_passage_times = first_passage_times
        self._count_matrix = count_matrix
        self._total_counts = total_counts
        self._total_times = total_times

        return self

    def max_likelihood_estimate(self):
        r"""Return the maximum likelihood estimate.

        Returns
        -------
        MarkovianMilestoningModel
            The model that maximizes the likelihood of the data.

        See Also
        --------
        msmtools.estimation.transition_matrix :
            Low-level function used to estimate the transition kernel.

        Notes
        -----
        The transition kernel is estimated from the observed transition 
        count matrix :math:`N` by maximizing the likelihood

        .. math:: \mathbb{P}(N|K)\propto\prod_{a,b}K_{ab}^{N_{ab}}.

        In the nonreversible case, this gives the estimate 
        :math:`\hat{K}_{ab}=N_{ab}/N_a`, where :math:`N_a=\sum_{b}N_{ab}` 
        is the total number of transitions starting from milestone 
        :math:`a`. In the reversible case, the maximization is subject to
        the constraint of detailed balance. For details see Section III 
        of Trendelkamp-Schroer et al. [1]_ 

        The mean lifetime of milestone :math:`a` is estimated by
        :math:`\hat{\tau}_a=T_a/N_a`, where :math:`T_a` is the total time 
        spent in milestone state :math:`a`.

        """
        return self._model

    def posterior_sample(self, size=100):
        r"""Generate a sample from the posterior distribution.

        Parameters
        ----------
        size : int, optional
            The sample size, i.e., the number of models to generate.

        Returns
        -------
        list[MarkovianMilestoningModel]
            The sampled models.

        See Also
        --------
        msmtools.estimation.tmatrix_sampler :
            Low-level function used to sample transition kernels.

        Notes
        -----
        Transition kernels are sampled from the posterior distribution

        .. math:: \mathbb{P}(K|N) \propto \mathbb{P}(K)
                                          \prod_{a,b} K_{ab}^{N_{ab}},

        where the prior :math:`\mathbb{P}(K)` depends on whether detailed
        balance is assumed. For details see Section IV of
        Trendelkamp-Schroer et al. [1]_ Sampling is initiated from the
        maximum likelihood estimate of :math:`K`.

        The mean lifetime of milestone :math:`a` is sampled from an 
        inverse Gamma distribution with shape :math:`N_a` and scale
        :math:`T_a`.

        """
        if self._model is None:
            return None

        sampler = estimation.tmatrix_sampler(
            self._count_matrix, reversible=self.reversible,
            T0=self._model.transition_kernel)
        Ks = sampler.sample(nsamples=size)
        for K in Ks:
            np.fill_diagonal(K, 0)

        rng = np.random.default_rng()
        vs = np.zeros((size, self._model.n_states))
        for i, (n, r) in enumerate(zip(self._total_counts, self._total_times)):
            vs[:, i] = rng.gamma(n, scale=1/r, size=size)

        return [MarkovianMilestoningModel(K, 1/v, self._model.states) 
                for K, v in zip(Ks, vs)]

    def first_passage_times(self, source, target):
        """Sampled first passage times for each milestone pair.

        Parameters
        ----------
        source : frozenset
            Index of the source milestone.

        target : frozenset
            Index of the target milestone.

        Returns
        -------
        list
            Sampled first passage times from `source` to `target`.

        """
        return self._first_passage_times[source, target]


class TrajectoryColoring:
    """Mapping from continuous trajectories to milestone schedules.

    The mapping is determined by a Voronoi partition of the state space.
        
    Parameters
    ----------
    anchors : (N, d) array_like
        Generating points for Voronoi tessellation.
    parent_cell : (N,) array_like of int, optional
        The cell index associated with each anchor. Can be used to 
        define a Voronoi diagram with sites that are sets of anchors
        rather than single anchors. Default is range(N).
    boxsize : (d,) array_like or scalar, optional
        Apply `d`-dimensional toroidal topology (periodic boundary 
        conditions).
    cutoff : positive float, optional
        Maximum distance to the nearest anchor. The region of state space
        outside the cutoff is treated as a cell with index -1.
    forward : bool, optional
        If True, track the next milestone hit (forward commitment),
        rather than the last milestone hit (backward commitment). Default
        is False.

    """

    def __init__(self, anchors, parent_cell=None, boxsize=None, cutoff=None,
                 forward=False):
        self._kdtree = scipy.spatial.cKDTree(anchors, boxsize=boxsize)
        self.cutoff = cutoff
        self.parent_cell = parent_cell
        self.forward = forward

    @property
    def anchors(self):
        """(N, d) ndarray: Generating points of the Voronoi tessellation."""
        return self._kdtree.data

    @property
    def boxsize(self):
        """(d,) ndarray: Periodic box lengths."""
        return self._kdtree.boxsize

    @property
    def cutoff(self):
        """float: Maximum distance to nearest anchor."""
        return self._cutoff

    @cutoff.setter
    def cutoff(self, value):
        if value is None:
            self._cutoff = np.inf
        else:
            if value <= 0:
                raise ValueError('cutoff must be positive')
            self._cutoff = float(value)

    @property
    def parent_cell(self):
        """(N,) ndarray of int: Cell index associated with each anchor."""
        if np.isfinite(self.cutoff):
            return self._parent_cell[:-1]
        return self._parent_cell

    @parent_cell.setter
    def parent_cell(self, value):
        if value is None:
            value = np.arange(self._kdtree.n)
        else:
            value = msmtools.util.types.ensure_dtraj(value)
            if len(value) != self._kdtree.n:
                msg = 'number of cell indices much match number of anchors'
                raise ValueError(msg)
        if np.isfinite(self.cutoff):
            value = np.append(value, -1) 
        self._parent_cell = value

    @property
    def forward(self):
        """bool: Whether to map to a forward milestoning process."""
        return self._forward

    @forward.setter
    def forward(self, value):
        self._forward = bool(value)

    def transform(self, traj):
        """Map a trajectory to its milestone schedule.

        Parameters
        ----------
        traj : sequence of (d,) array_like
            A trajectory in `d`-dimensional space.

        Returns
        -------
        schedule : Sequence[tuple[frozenset, int]]
            A sequence of (milestone state, lifetime) pairs.

        """
        dtraj = self._assign_cells(traj)
        return color_discrete_trajectory(dtraj, forward=self.forward)

    def __call__(self, trajs):
        return self.transform(trajs)
 
    def _assign_cells(self, x):
        _, k = self._kdtree.query(x, distance_upper_bound=self.cutoff)
        return self.parent_cell[k]
 

def color_discrete_trajectory(dtraj, forward=False):
    """Map a discrete-state trajectory to a milestone schedule.

    Parameters
    ----------
    dtraj : sequence
        A discrete-state trajectory, e.g., a sequence of cell indices. 
        Values must be hashable. The value None is reserved to indicate 
        an undefined state.
    forward : bool, optional
        If True, track the next milestone hit (forward commitment),
        rather than the last milestone hit (backward commitment). Defaut 
        is False.

    Returns
    -------
    Sequence[tuple[frozenset, int]]
        A sequence of (milestone state, lifetime) pairs. 

    Notes
    -----
    When `forward` is False (ordinary milestoning), the initial milestone
    state is set to ``frozenset({None, dtraj[0]})``. When `forward` is
    True, the final milestone state is set to 
    ``frozenset({dtraj[-1], None})``.
 
    """
    dtraj_it = reversed(dtraj) if forward else iter(dtraj)
    i = next(dtraj_it)
    milestones = [frozenset({None, i})]
    lifetimes = [0]
    for j in dtraj_it:
        lifetimes[-1] += 1
        if j not in milestones[-1]:
            milestones.append(frozenset({i, j}))
            lifetimes.append(0)
        i = j
    if forward:
        return list(zip(reversed(milestones), reversed(lifetimes))) 
    return list(zip(milestones, lifetimes))
 
